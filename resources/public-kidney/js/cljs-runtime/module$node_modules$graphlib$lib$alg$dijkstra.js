shadow$provide.module$node_modules$graphlib$lib$alg$dijkstra=function(global,require,module,exports){function runDijkstra(g,source,weightFn,edgeFn){var results={},pq=new PriorityQueue,updateNeighbors=function(edge){var w=edge.v!==v$jscomp$0?edge.v:edge.w,wEntry=results[w],weight=weightFn(edge),distance=vEntry.distance+weight;if(0>weight)throw Error("dijkstra does not allow negative edge weights. Bad edge: "+edge+" Weight: "+weight);distance<wEntry.distance&&(wEntry.distance=distance,wEntry.predecessor=
v$jscomp$0,pq.decrease(w,distance))};for(g.nodes().forEach(function(v){var distance=v===source?0:Number.POSITIVE_INFINITY;results[v]={distance};pq.add(v,distance)});0<pq.size();){var v$jscomp$0=pq.removeMin();var vEntry=results[v$jscomp$0];if(vEntry.distance===Number.POSITIVE_INFINITY)break;edgeFn(v$jscomp$0).forEach(updateNeighbors)}return results}global=require("module$node_modules$graphlib$lib$lodash");var PriorityQueue=require("module$node_modules$graphlib$lib$data$priority_queue");module.exports=
function(g,source,weightFn,edgeFn){return runDijkstra(g,String(source),weightFn||DEFAULT_WEIGHT_FUNC,edgeFn||function(v){return g.outEdges(v)})};var DEFAULT_WEIGHT_FUNC=global.constant(1)}
//# sourceMappingURL=module$node_modules$graphlib$lib$alg$dijkstra.js.map
