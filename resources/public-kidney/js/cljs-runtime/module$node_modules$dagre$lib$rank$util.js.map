{
"version":3,
"file":"module$node_modules$dagre$lib$rank$util.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,uCAAA,CAA4D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGpG,IAAIC,EAAIH,OAAA,CAAQ,sCAAR,CAERC,OAAOC,CAAAA,OAAP,CAAiB,CACfE,YAyBFA,QAAoB,CAACC,CAAD,CAAI,CAGtBC,QAASA,IAAG,CAACC,CAAD,CAAI,CACd,IAAIC,MAAQH,CAAEI,CAAAA,IAAF,CAAOF,CAAP,CACZ,IAAIJ,CAAEO,CAAAA,GAAF,CAAMC,OAAN,CAAeJ,CAAf,CAAJ,CACE,MAAOC,MAAMI,CAAAA,IAEfD,QAAA,CAAQJ,CAAR,CAAA,CAAa,CAAA,CAETK,EAAAA,CAAOT,CAAEU,CAAAA,GAAF,CAAMV,CAAEW,CAAAA,GAAF,CAAMT,CAAEU,CAAAA,QAAF,CAAWR,CAAX,CAAN,CAAqB,QAAQ,CAACS,CAAD,CAAI,CAChD,MAAOV,IAAA,CAAIU,CAAEC,CAAAA,CAAN,CAAP,CAAkBZ,CAAEa,CAAAA,IAAF,CAAOF,CAAP,CAAUG,CAAAA,MADoB,CAAjC,CAAN,CAIX,IAAIP,CAAJ,GAAaQ,MAAOC,CAAAA,iBAApB,EACaC,IAAAA,EADb,GACIV,CADJ,EAEa,IAFb,GAEIA,CAFJ,CAGEA,CAAA,CAAO,CAGT,OAAQJ,MAAMI,CAAAA,IAAd,CAAqBA,CAjBP,CAFhB,IAAID,QAAU,EAsBdR,EAAEoB,CAAAA,OAAF,CAAUlB,CAAEmB,CAAAA,OAAF,EAAV,CAAuBlB,GAAvB,CAvBsB,CA1BP,CAEfmB,MAsDFA,QAAc,CAACpB,CAAD,CAAIW,CAAJ,CAAO,CACnB,MAAOX,EAAEI,CAAAA,IAAF,CAAOO,CAAEC,CAAAA,CAAT,CAAYL,CAAAA,IAAnB;AAA0BP,CAAEI,CAAAA,IAAF,CAAOO,CAAET,CAAAA,CAAT,CAAYK,CAAAA,IAAtC,CAA6CP,CAAEa,CAAAA,IAAF,CAAOF,CAAP,CAAUG,CAAAA,MADpC,CAxDJ,CALmF;",
"sources":["node_modules/dagre/lib/rank/util.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$dagre$lib$rank$util\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = {\n  longestPath: longestPath,\n  slack: slack\n};\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (_.has(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(_.map(g.outEdges(v), function(e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    }));\n\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n        rank === undefined || // return value of _.map([]) for Lodash 4\n        rank === null) { // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","_","longestPath","g","dfs","v","label","node","has","visited","rank","min","map","outEdges","e","w","edge","minlen","Number","POSITIVE_INFINITY","undefined","forEach","sources","slack"]
}
