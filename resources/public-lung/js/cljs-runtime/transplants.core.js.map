{"version":3,"sources":["transplants/core.cljs"],"mappings":";AAaA,AAACA;AAID,AAAKC,gCAAgBC;AAErB,6BAAA,7BAAMC;AAAN,AACE,GAAMF;AAAN,AACE,OAACD;;AADH;;;AAIF;;;;;8BAAA,9BAAuBI;AAAvB,AAKE,AAACC;;AACD,AAACC;;AACD,wDAAA,8HAAA,iHAAA,2CAAA,mFAAA,2FAAA,zfAACC,oIAAWC,8HACCC,kIAA2BC;AADxC,AAE0D,6DAAA,mFAAA,zIAACC;2BAChD,wBAAA,xBAAiBC;;AAE9B;;;oCAAA,pCAAMC,gFAEHC;AAFH,AAKE,8BAAA,mFAAA,1GAACC,+NAA0C,AAAcC;;AAE3D,AAIA;;;;;;;;;;;wBAAA,xBAAeC;AAAf,AAaE,4BAAA,mFAAA,/GAACC;;AAED,4BAAA,mFAAA,wGAAA,mHAAA,mFAAA,7ZAACA,0SAA0CC;;AAO3C,wBAAA,xBAAmBH,iCAAmBH;;AACtC,AAACV;;AAED,OAACC;;;AAKH;;;6BAAA,7BAAegB;AAAf,AAGE,YAAA,ZAACC;;AACD,OAACJ;;;AAGH;;;+BAAA,/BAAeK;AAAf,AAGE,YAAA,ZAACD;;AACD,OAACJ","names":["cljs.core/enable-console-print!","transplants.core/debug?","js/goog.DEBUG","transplants.core/dev-setup","transplants.core/mount-root","re-frame.core/clear-subscription-cache!","transplants.routes/init-routes!","reagent.dom.render","error-boundary.error-boundary/err-boundary","transplants.ui/root-component","transplants.routes/router","re_frame.core.subscribe","js/document","transplants.core/on-window-resize","_evt","re-frame.core/dispatch","js/window","transplants.core/init","re-frame.core/dispatch-sync","transplants.paths/metadata-path","transplants.core/lung-init","js/console.log","transplants.core/kidney_init"],"sourcesContent":["(ns ^:figwheel-hooks transplants.core\n  (:require\n   [reagent.dom :as rd]\n   [re-frame.core :as rf]\n   [transplants.routes :as routes]\n   [transplants.events :as events]\n   [transplants.subs :as subs]\n   [transplants.paths :as paths]\n   [transplants.ui :as ui]\n   [error-boundary.error-boundary :refer [err-boundary]]\n   ;[shadow.debug :refer [locals ?> ?-> ?->>]]\n   ))\n\n(enable-console-print!)\n\n\n;;; Setup ;;;\n(def debug? ^boolean goog.DEBUG)\n\n(defn dev-setup []\n  (when debug?\n    (enable-console-print!)\n    #_(println \"dev mode\")))\n\n(defn ^:dev/after-load mount-root\n  \"Mount components and start the reitit router. The :dev/after-load meta-data causes\n   shadow-cljs to call mount-root after a hot-reload and clear the subsciption cache so\n   everything gets updated nicely.\"\n  []\n  (rf/clear-subscription-cache!)\n  (routes/init-routes!) ;; Reset routes on figwheel reload\n  (rd/render [err-boundary\n              [ui/root-component {:router routes/router\n                                  :subscribe-current-route #(rf/subscribe [::subs/current-route])}]]\n             (.getElementById js/document \"app\")))\n\n(defn on-window-resize\n  \"Handle window-size change by dispatching new width to db\"\n  [_evt]\n  ; TODO: debounce this to avoid stupidly small and frequent resizing\n  ; e.g. record time of last update and only change width after 100ms have elapsed.\n  (rf/dispatch [::events/update-window-width (.-innerWidth js/window)]))\n\n(comment\n  (mount-root)\n  )\n\n(defn ^:export init\n  \"Initialise the database, sense window-width, and mount root of component tree. \n   \n   We're breaking the rules slightly as this is an :afer-load function, which shadow-cljs docs \n   say must be synchronous. However the parts that need to be synchronous here are, and we \n   let the UI display a 'loading' state till the async dispatches complete. \n   \n   If we coded this up as an :after-load-async function we'd need to provide a `done` function \n   to call on completion. Meanwhile, the UI would be dead.\n   \"\n  []\n  ;(enable-console-print!)\n\n  (rf/dispatch-sync [::events/initialize-db])\n\n  (rf/dispatch-sync [::events/load-metadata [paths/metadata-path [:metadata]]])\n\n  ;;; Removing the following two lines as they hard-coded lung and kidney organs into the tool\n  ;;; Instead, we obtain the organ list by reading in the metadata file above.\n  ;;(rf/dispatch [::events/load-and-transpose [(paths/centres-path :lung) [:organ-centres :lung]]])\n  ;;(rf/dispatch [::events/load-and-transpose [(paths/centres-path :kidney) [:organ-centres :kidney]]])\n\n  (.addEventListener js/window \"resize\" on-window-resize)\n  (dev-setup)\n\n  (mount-root)) \n\n; Not needed for shadow-cljs where init is declared as a module entry point\n;(defonce start-up (do (init) true))\n\n(defn ^:export lung-init\n  \"Entry point for the lung app\"\n  []\n  (js/console.log \"LUNG\")\n  (init)\n  )\n\n(defn ^:export kidney_init\n  \"Entry point for the kidney app\"\n  []\n  (js/console.log \"KIDNEY\")\n  (init)\n  )"]}