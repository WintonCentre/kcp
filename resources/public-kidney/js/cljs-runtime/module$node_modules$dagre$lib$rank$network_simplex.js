shadow$provide.module$node_modules$dagre$lib$rank$network_simplex=function(global,require,module,exports){function networkSimplex(g){g=simplify(g);initRank(g);var t=feasibleTree(g);initLowLimValues(t);initCutValues(t,g);for(var e,f;e=leaveEdge(t);)f=enterEdge(t,g,e),exchangeEdges(t,g,e,f)}function initCutValues(t,g){var vs=postorder(t,t.nodes());vs=vs.slice(0,vs.length-1);_.forEach(vs,function(v){var parent=t.node(v).parent;t.edge(v,parent).cutvalue=calcCutValue(t,g,v)})}function calcCutValue(t,g,
child){var parent=t.node(child).parent,childIsTail=!0,graphEdge=g.edge(child,parent),cutValue=0;graphEdge||(childIsTail=!1,graphEdge=g.edge(parent,child));cutValue=graphEdge.weight;_.forEach(g.nodeEdges(child),function(e){var isOutEdge=e.v===child,other=isOutEdge?e.w:e.v;other!==parent&&(isOutEdge=isOutEdge===childIsTail,e=g.edge(e).weight,cutValue+=isOutEdge?e:-e,t.hasEdge(child,other)&&(other=t.edge(child,other).cutvalue,cutValue+=isOutEdge?-other:other))});return cutValue}function initLowLimValues(tree,
root){2>arguments.length&&(root=tree.nodes()[0]);dfsAssignLowLim(tree,{},1,root)}function dfsAssignLowLim(tree,visited,nextLim,v,parent){var low=nextLim,label=tree.node(v);visited[v]=!0;_.forEach(tree.neighbors(v),function(w){_.has(visited,w)||(nextLim=dfsAssignLowLim(tree,visited,nextLim,w,v))});label.low=low;label.lim=nextLim++;parent?label.parent=parent:delete label.parent;return nextLim}function leaveEdge(tree){return _.find(tree.edges(),function(e){return 0>tree.edge(e).cutvalue})}function enterEdge(t,
g,edge$jscomp$0){var v=edge$jscomp$0.v,w=edge$jscomp$0.w;g.hasEdge(v,w)||(v=edge$jscomp$0.w,w=edge$jscomp$0.v);edge$jscomp$0=t.node(v);w=t.node(w);var tailLabel=edge$jscomp$0,flip=!1;edge$jscomp$0.lim>w.lim&&(tailLabel=w,flip=!0);w=_.filter(g.edges(),function(edge){var JSCompiler_temp_const=flip,vLabel=t.node(edge.v);if(JSCompiler_temp_const=JSCompiler_temp_const===(tailLabel.low<=vLabel.lim&&vLabel.lim<=tailLabel.lim))JSCompiler_temp_const=flip,edge=t.node(edge.w),JSCompiler_temp_const=JSCompiler_temp_const!==
(tailLabel.low<=edge.lim&&edge.lim<=tailLabel.lim);return JSCompiler_temp_const});return _.minBy(w,function(edge){return slack(g,edge)})}function exchangeEdges(t,g,e,f){t.removeEdge(e.v,e.w);t.setEdge(f.v,f.w,{});initLowLimValues(t);initCutValues(t,g);updateRanks(t,g)}function updateRanks(t,g){var root=_.find(t.nodes(),function(v){return!g.node(v).parent});root=preorder(t,root);root=root.slice(1);_.forEach(root,function(v){var parent=t.node(v).parent,edge=g.edge(v,parent),flipped=!1;edge||(edge=g.edge(parent,
v),flipped=!0);g.node(v).rank=g.node(parent).rank+(flipped?edge.minlen:-edge.minlen)})}var _=require("module$node_modules$dagre$lib$lodash"),feasibleTree=require("module$node_modules$dagre$lib$rank$feasible_tree"),slack=require("module$node_modules$dagre$lib$rank$util").slack,initRank=require("module$node_modules$dagre$lib$rank$util").longestPath,preorder=require("module$node_modules$dagre$lib$graphlib").alg.preorder,postorder=require("module$node_modules$dagre$lib$graphlib").alg.postorder,simplify=
require("module$node_modules$dagre$lib$util").simplify;module.exports=networkSimplex;networkSimplex.initLowLimValues=initLowLimValues;networkSimplex.initCutValues=initCutValues;networkSimplex.calcCutValue=calcCutValue;networkSimplex.leaveEdge=leaveEdge;networkSimplex.enterEdge=enterEdge;networkSimplex.exchangeEdges=exchangeEdges}
//# sourceMappingURL=module$node_modules$dagre$lib$rank$network_simplex.js.map
