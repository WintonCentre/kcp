{"version":3,"sources":["winton_utils/data_frame.cljc"],"mappings":"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","names":["winton-utils.data-frame/map-of-vs->v-of-maps","k-vs","cljs.core/seq","cljs.core.mapv","vs","cljs.core.into","cljs.core.map_indexed","k","v","cljs.core.nth","cljs.core/keys","cljs.core.apply","cljs.core/map","cljs.core/vector","cljs.core/vals","winton-utils.data-frame/v-of-maps->map-of-vs","ms","ks","cljs.core.mapcat","cljs.core/juxt","i","cljs.core.map","val","winton-utils.data-frame/cell-apply","f","p__81081","vec__81082","winton-utils.data-frame/cell-update","p__81089","vec__81090","g","cljs.core.partial","p__81094","vec__81095","winton-utils.data-frame/cell-sums","cljs.core.reductions","cljs.core/+","winton-utils.data-frame/cell-diffs","initial","p__81099","vec__81100","p__81103","vec__81104","a","b","cljs.core.partition","cljs.core/cons","winton-utils.data-frame/cell-binary","df","p__81111","vec__81112","cljs.core.completing","winton-utils.data-frame/cell-binary-seq","cs","p__81115","vec__81116"],"sourcesContent":["(ns winton-utils.data-frame)\n\n(defn map-of-vs->v-of-maps\n  \"Transpose a map of vectors to a vector of maps.\n  Resulting vector will be truncated to the length of the shortest input vector.\n  e.g. {:a [0 1 2] :b [10 11 12]} -> [{:a 0 :b 10} {:a 1 :b 11} {:a 2 :b 12}]\"\n  [k-vs]\n  (cond\n    (seq k-vs)\n    (mapv (fn [vs]\n            (into {} (map-indexed (fn [k v] [(nth (keys k-vs) k) v]) vs)))\n          (apply map vector (vals k-vs)))\n    (nil? k-vs)\n    nil\n\n    :else\n    []))\n\n\n(defn v-of-maps->map-of-vs\n  \"Transpose a vector of maps to a map of vectors.\n  Resulting vector will be truncated to the length of the shortest input vector.\n  e.g. [{:a 0 :b 10} {:a 1 :b 11} {:a 2 :b 12}] -> {:a [0 1 2] :b [10 11 12]}\"\n  [ms]\n  (when ms\n    (let [ks (into #{} (mapcat keys ms))\n          vs (if (seq ks) (mapv (apply juxt ks) ms) [])]\n      (into {} (map-indexed\n                 (fn [i k] [k (map (fn [val] (val i)) vs)])\n                 ks))\n      ))\n  )\n\n\n\n(comment\n  ;; wip\n\n  (defn step [vms [k vs]]\n    (map-indexed\n      (fn [i m]\n        (update m k (fn [old-v] (into [] (conj old-v (k m))))))\n      vms))\n\n  (comment\n    (step [] [:a [1 2 3]])\n    ;=> ({:a [1]} {:a [2]} {:a [3]})\n\n    (step {} [:a [1 2 3]])\n\n    (reduce step {} [[:a [1 2 3 4]] [:b [2 3 4 5]]])\n\n    (v-of-maps->map-of-vs {:a [1 2 3 4] :b [2 3 4 5]})\n    ;=> [{:a 1 :b 2} {:a 2 :b 3} {:a 3 :b 4} {:a 4 :b 5}]\n\n    )\n\n  )\n\n\n;;\n;; Implement a set of functions which can be used to make transducers that operate on data-frames.\n;;\n;; In this context a data-frame\n;; is a rectangular table of data in columns where each column is identified by a keyword.\n;;\n;; Example 1:\n;; (def df {:a [1 2 3] :b [4 5 6] :c [7 8 9] :d [10 11 12]})\n;;\n;; Example 2:\n;; A spreadsheet with keywords for column names\n;;\n\n\n(defn cell-apply [f]\n  (fn [[k vs]] [k (map f vs)]))\n\n(comment\n  (into {} (map (cell-apply inc)) {:a (range 10) :b (range 5 15)})\n  ;=> {:a (1 2 3 4 5 6 7 8 9 10), :b (6 7 8 9 10 11 12 13 14 15)}\n  )\n\n(defn cell-update [f]\n  \"update a cell at position k index with old value to a new value\n  given by (f k index old)\"\n  (fn [[k vs]]\n    (let [g (partial f k)]                                  ;(fn [index old] (f k index old))\n      [k (map-indexed g vs)])))\n\n(comment\n  (into {}\n        (map (cell-update (fn [k index old] (str k \"-\" index \"-\" old))))\n        {:a [1 2 3] :b [4 5 6]})\n  ;=> {:a (\":a-0-1\" \":a-1-2\" \":a-2-3\"), :b (\":b-0-4\" \":b-1-5\" \":b-2-6\")}\n  )\n\n(defn cell-sums\n  [[k vs]]\n  [k (reductions + vs)])\n\n(comment\n  (into {} (map cell-sums) '([:a [1 2 3]] [:b [4 5 6]] [:c [7 8 9]] [:d [10 11 12]]))\n  ;=> {:a (1 3 6), :b (4 9 15), :c (7 15 24), :d (10 21 33)}\n  )\n\n(defn cell-diffs\n  [initial]\n  (fn [[k vs]]\n    [k (map (fn [[a b]] (- b a)) (partition 2 1 (cons initial vs)))]))\n\n(comment\n  (into {} (map (diff-cells 0)) '([:a [0 1 2 3]] [:b [1 6 5 4]] [:c [3 3 3 4]] [:d [0 -1 -2]]))\n  ;=> {:a (0 1 1 1), :b (1 5 -1 -1), :c (3 0 0 1), :d (0 -1 -1)}\n\n  (into {} (map (diff-cells 1)) '([:a [0 1 2 3]] [:b [1 6 5 4]] [:c [3 3 3 4]] [:d [0 -1 -2]]))\n  ;=> {:a (-1 1 1 1), :b (0 5 -1 -1), :c (2 0 0 1), :d (-1 -1 -1)}\n  )\n\n(defn cell-binary\n  \"Apply a binary function to merge cells from the input dataframe with cells from df\"\n  [f df]\n  (fn [[k vs]] [k (map (completing f) (k df) vs)]))\n\n\n(defn cell-binary-seq\n  \"Apply a binary function to merge cells from the input dataframe with cells from a seq\"\n  [f cs]\n  (fn [[k vs]] [k (map (completing f) cs vs)]))\n\n(comment\n  (into {}\n        (map (cell-binary + {:a (range 10 20) :b (range 10)}))\n        {:a (range -10 -20 -1) :b (range 0 -10 -1)})\n  ; => {:a (0 0 0 0 0 0 0 0 0 0), :b (0 0 0 0 0 0 0 0 0 0)}\n  )\n\n\n(comment\n\n  ;; compose transducers\n  (def xf (comp\n            (map (cell-apply inc))\n            (map cell-sums)\n            (map (cell-diffs 0))\n            (map (cell-apply dec))\n            ))\n  (into {} xf {:a (range 10) :b (range 5 15)})\n  ; {:a (0 1 2 3 4 5 6 7 8 9), :b (5 6 7 8 9 10 11 12 13 14)}\n\n  (def a (transduce xf conj {:a (range 10) :b (range 5 15)}))\n  (def r (eduction xf {:a (range 10) :b (range 5 15)}))\n\n  ;; The mapping transducer (mapping f) is equivalent to (map f)\n  ;; https://stackoverflow.com/questions/32822207/eduction-vs-transducer-composition\n  (defn mapping\n    ([f]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n          (rf result (f input)))))))\n\n  ;; experimenting with eduction\n\n  )\n\n"]}