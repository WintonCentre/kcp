{"version":3,"sources":["transplants/bsio.cljs"],"mappings":"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","names":["transplants.bsio/missing-color","p__67832","map__67834","cljs.core/--destructure-map","cljs.core.get","transplants.bsio/radio-button-group","id","value-f","on-change","buttons-f","_vertical","_optional","value","buttons","highlight?","lev","cljs.core._EQ_","cljs.core/first","p1__67831#","cljs.core.filter","cljs.core.into","js/module$node_modules$react_bootstrap$cjs$index.ToggleButtonGroup","cljs.core.map","p__67843","map__67844","level-name","level","js/module$node_modules$react_bootstrap$cjs$index.ToggleButton","transplants.rgb/theme","p__67856","map__67858","transplants.bsio/dropdown","p1__67850#","js/module$node_modules$react_bootstrap$cjs$index.Dropdown","G__67863","cljs.core.keyword","js/module$node_modules$react_bootstrap$cjs$index.DropdownButton","temp__5751__auto__","x","cljs.core/seq","p__67871","map__67872","p__67889","map__67890","p1__67852#","js/module$node_modules$react_bootstrap$cjs$index.Dropdown.Item","p__67902","map__67903","transplants.bsio/reset-button","on-click","js/module$node_modules$react_bootstrap$cjs$index.Button","transplants.bsio/modal","data-f","map__67913","cljs.core/deref","title","content","cancel","save","ok","data","js/module$node_modules$react_bootstrap$cjs$index.Modal","js/module$node_modules$react_bootstrap$cjs$index.Modal.Header","js/module$node_modules$react_bootstrap$cjs$index.Modal.Title","js/module$node_modules$react_bootstrap$cjs$index.Modal.Body","js/module$node_modules$react_bootstrap$cjs$index.Modal.Footer"],"sourcesContent":["(ns transplants.bsio\n  \"A (react) bootstrap i/o wrapper. There's an example of a boostrap text input component in the comment\nwhere we can work on defining a common interface. \"\n  (:require [\"react-bootstrap\" :as bs]\n            [transplants.rgb :as rgb]\n            ;[shadow.debug :refer [locals ?> ?-> ?->>]]\n            ))\n\n(def missing-color \"#ff0000\")\n\n(comment\n\n  (defn example\n    \"This example defines an interface for reading and writing application state. \nIt borrows some language from re-frame.\n\n`value-k` is a keyword which uniquely identifies a value to be written to the application. \nThis will likely be a factor key as defined by the model spreadsheet.\n\n`value-f` is a function that reads a value from the application when called. \nThe caller can define `value-f` in a number of ways:\n(fn [] @(rf/subscribe k))       ; Caller is closing over the subscription key here and supplies a deref\n                                ; which will happen inside the bsio component.\n(fn [] @ref-value)              ; Caller has already subscribed, but wants the component to deref.\n(fn [] plain-value)             ; Caller is simply providing a value. \nBy passing in a function the caller can control where and how often the dereferencing happens. \nIn all cases the bsio component simply calls value-f to get the needed value.\nWe can't assume that value-k identifies (value-f) though it often will.\n\n`event-f` is a function for reporting events that change the value referenced by value-k\n\n`options` is a map for anything else we might need to pass in - e.g. labels or style or size choices.\n[If we use bs4 Forms here, we'll need to do this, but it's the sort of things that is really app\nresponsibility. However some component like checkboxes (we don't need them at the moment), do require \nlabels to be part of the same form control because they are part of the clickable area.]\n\nThe example uses a raw input component, but it may be desirable to replace that in the real library \nwith a react-bootstrap Form.Control so we can use them to flag invalid or empty values. \n\nThe caller would have to provide wrapping Form components like InputGroup in that case. \nI doubt that those would need to be part of this library. Each component would likely be wrapped in \nits own Form in that case. That's for the next level up to worry about.\n\nSome experimentation with Forms is necessary to check it's a viable approach that allows the \nlow level inputs to react to value changes without the user having to press a submit button. Hopefully it is.\n\nI've also missed out things like stopPropagation, preventDefault, and touch events.\n\n\"\n    [value-k value-f event-f & [_options]]\n    (let [handle-change (fn [e] (event-f [value-k (-> e .-target .-value)]))]\n      [:input {:type \"text\" :value (value-f) :on-change handle-change}])))\n\n(defn radio-button-group\n  \"Add in correct toggle operation.\n   The id may be used to locate this widget in E2E tests.\n   value-f is a function which, when called returns the current value of the widget.\n   event-f is an event handler which is called when the selected level changes\n   Each button is configured with a map wih the (buttons-f) containing its :level-name, :level, and :disabled status.\"\n  [{:keys [id value-f on-change buttons-f _vertical _optional]}]\n  [:<>\n   (let [value (value-f)\n         buttons (buttons-f)\n         highlight? (fn [lev] (and (= value :unknown)\n                                   (= lev (:optional (first (filter #(= (:level %) :unknown) buttons))))))]\n     (into [:> bs/ToggleButtonGroup\n            {:type \"radio\"\n             :id id\n             ;:inline \"true\"\n             ;:size \"sm\"\n             ;:vertical vertical \n             :name id\n             :value value\n             :on-change on-change\n             :style  {:margin-top 5\n                      :border (str \"3px solid \"\n                                   (if (nil? value)\n                                     missing-color\n                                     (if (= value :unknown)\n                                       \"teal\"\n                                       \"#CCCCCC\")))\n                      :border-radius 5\n                      :padding 1\n                      :display \"flex\"\n                      :justify-content \"space-between\"\n                      :flex-wrap \"wrap\"}}]\n           (map (fn [{:keys [level-name level]}]\n                  [:> bs/ToggleButton {:type \"checkbox\"\n                                       :class-name \"toggler\"\n                                       :key level :disabled false\n                                       :value level\n                                       :style {:border-radius 0\n                                               :margin 0\n                                               :color (when (highlight? level) \"#00B\")\n                                               :font-weight (when (highlight? level) \"bold\")\n                                               :background-color (if (highlight? level)\n                                                                   \"#fec\"\n                                                                   (if (= level value) \n                                                                     rgb/theme \n                                                                     \"#fff\"))}\n                                       :variant \"outline-secondary\"}\n                   level-name])\n                buttons)))])\n\n(defn dropdown\n  [{:keys [id value-f on-change buttons-f]}]\n\n  (let [value (value-f)\n        buttons (buttons-f)]\n\n    [:> bs/Dropdown\n     {:on-select #(on-change (keyword %))}\n\n     (into [:> bs/DropdownButton\n            {:id id\n             :value value\n             :variant (if (nil? value) \"outline-secondary\" \"secondary\")\n             :title  (:level-name (first (if-let [x (seq (filter (fn [{:keys [level]}]\n                                                              (= value level)) buttons))]\n                                      x (buttons-f))))\n             :style  {:border (str \"3px solid \" (if (nil? value) missing-color \"#ffffff\"))\n                      :border-radius 5\n                      :padding 1\n                      :width \"max-content\"}}]\n           (map (fn [{:keys [level-name level]}]\n                  [:> bs/Dropdown.Item {:key level :as \"button\"\n                                        :eventKey level\n                                        :on-click #(.preventDefault %)}\n                   level-name])\n                (buttons-f)))]))\n\n(defn reset-button\n  [{:keys [on-click]}]\n  [:> bs/Button {:variant \"danger\" ;\"secondary\"\n                 :id \"reset\"\n                 :style {:margin-bottom 10}\n                 :on-click on-click} \"Reset all\"])\n\n(comment\n  ; white border when there is a value\n  (:border (:style (nth (second (radio-button-group {:value-path [:sex]\n                                                     :value-f (fn [] :male)\n                                                     :on-change identity\n                                                     :buttons-f (fn [] [{:level :male :level-name \"Male\"}\n                                                                        {:level :female :level-name \"Female\"}])}))\n                        2)))\n\n  ; red border when there isn't\n  (:border (:style (nth (second (radio-button-group {:value-path [:sex]\n                                                     :value-f (fn [] nil)\n                                                     :on-change identity\n                                                     :buttons-f (fn [] [{:level :male :level-name \"Male\"}\n                                                                        {:level :female :level-name \"Female\"}])}))\n                        2))))\n\n\n(defn modal\n  \"A modal dialog box\"\n  [data-f]\n  ;(locals)\n  (let [{:keys [title content cancel save ok] :as data} @(data-f)]\n    (when data\n      [:> bs/Modal {:show true :on-hide ok}\n       [:> bs/Modal.Header {:close-button true}\n        [:> bs/Modal.Title title]]\n       [:> bs/Modal.Body content]\n       [:> bs/Modal.Footer\n        (when cancel [:> bs/Button {:variant \"secondary\" :on-click cancel}\n                      \"Cancel\"])\n        (if save\n          [:> bs/Button {:variant \"primary\" :on-click save} \"Save\"]\n          [:> bs/Button {:variant \"primary\" :on-click ok} \"OK\"])]])))"]}