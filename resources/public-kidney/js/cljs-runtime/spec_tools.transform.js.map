{"version":3,"sources":["spec_tools/transform.cljc"],"mappings":"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","names":["spec-tools.transform/keyword->string","_","x","cljs.core/Keyword","spec-tools.impl/qualified-name","spec-tools.transform/keyword-or-string->","f","spec","G__65730","G__65731","spec-tools.transform/keyword->","G__65732","G__65733","spec-tools.transform/string->long","e65734","x'","js/parseInt","js/isNaN","js/Error","spec-tools.transform/string->double","e65735","js/parseFloat","spec-tools.transform/string->keyword","cljs.core.keyword","spec-tools.transform/string->boolean","cljs.core._EQ_","spec-tools.transform/string->uuid","e65736","cljs.core/re-find","cljs.core/uuid","spec-tools.transform/string->date","e65738","js/Date","js/goog.date.UtcDateTime.fromIsoString","spec-tools.transform/date->string","cljs.core/inst?","e65739","spec-tools.transform/string->symbol","cljs.core.symbol","spec-tools.transform/string->nil","spec-tools.transform/any->string","spec-tools.transform/number->double","spec-tools.transform/any->any","p__65740","map__65741","cljs.core/--destructure-map","keys","cljs.core.get","spec-tools.transform/strip-extra-keys","and__4251__auto__","cljs.core/map?","cljs.core/select-keys","p__65742","map__65743","spec-tools.transform/fail-on-extra-keys","clojure.set/subset?","cljs.core/keys","cljs.core/set","p__65745","map__65746","items","spec-tools.transform/strip-extra-values","size","cljs.core/count","cljs.core/vector?","cljs.core.subvec","spec-tools.transform/json-type-decoders","cljs.core.merge","spec-tools.transform/string-type-decoders","spec-tools.transform/strip-extra-keys-type-decoders","spec-tools.transform/fail-on-extra-keys-type-decoders","spec-tools.transform/strip-extra-values-type-decoders","spec-tools.transform/json-type-encoders","spec-tools.transform/string-type-encoders"],"sourcesContent":["(ns spec-tools.transform\n  #?(:cljs (:refer-clojure :exclude [Inst Keyword UUID]))\n  (:require [clojure.spec.alpha :as s]\n            #?@(:cljs [[goog.date.UtcDateTime]\n                       [goog.date.Date]])\n            [clojure.set :as set]\n            [spec-tools.parse :as parse]\n            [clojure.string :as str]\n            [spec-tools.impl :as impl])\n  #?(:clj\n     (:import (java.util Date UUID)\n              (java.time Instant ZoneId)\n              (java.time.format DateTimeFormatter DateTimeFormatterBuilder)\n              (java.time.temporal ChronoField))))\n\n;;\n;; Keywords\n;;\n\n(defn keyword->string [_ x]\n  (if (keyword? x)\n    (impl/qualified-name x)\n    x))\n\n(defn keyword-or-string-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      (string? x) (f spec x)\n      :else x)))\n\n(defn keyword-> [f]\n  (fn [spec x]\n    (cond\n      (keyword? x) (f spec (keyword->string spec x))\n      :else x)))\n;;\n;; Strings\n;;\n\n(defn string->long [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Long/parseLong x)\n         :cljs (let [x' (js/parseInt x 10)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->double [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Double/parseDouble x)\n         :cljs (let [x' (js/parseFloat x)]\n                 (if (js/isNaN x') x x')))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->keyword [_ x]\n  (if (string? x)\n    (keyword x)\n    x))\n\n(defn string->boolean [_ x]\n  (if (string? x)\n    (cond\n      (= \"true\" x) true\n      (= \"false\" x) false\n      :else x)\n    x))\n\n(defn string->uuid [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (UUID/fromString x)\n         ;; http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n         :cljs (if (re-find #\"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\" x)\n                 (uuid x)\n                 x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +string->date-format+\n     (-> (DateTimeFormatterBuilder.)\n         (.appendPattern \"yyyy-MM-dd['T'HH:mm:ss[.SSS][XXXX][XXXXX]]\")\n         (.parseDefaulting ChronoField/HOUR_OF_DAY 0)\n         (.parseDefaulting ChronoField/OFFSET_SECONDS 0)\n         (.toFormatter))))\n\n(defn string->date [_ x]\n  (if (string? x)\n    (try\n      #?(:clj  (Date/from (Instant/from (.parse +string->date-format+ x)))\n         :cljs (js/Date. (.getTime (goog.date.UtcDateTime.fromIsoString x))))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n#?(:clj\n   (def ^DateTimeFormatter +date->string-format+\n     (-> (DateTimeFormatter/ofPattern \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\")\n         (.withZone (ZoneId/of \"UTC\")))))\n\n(defn date->string [_ x]\n  (if (inst? x)\n    (try\n      #?(:clj  (.format +date->string-format+ (Instant/ofEpochMilli (inst-ms x)))\n         :cljs (.toISOString x))\n      (catch #?(:clj Exception, :cljs js/Error) _ x))\n    x))\n\n(defn string->symbol [_ x]\n  (if (string? x)\n    (symbol x)\n    x))\n\n(defn string->nil [_ x]\n  (if (= \"\" x)\n    nil\n    x))\n\n(defn any->string [_ x]\n  (if-not (nil? x)\n    (str x)))\n\n(defn number->double [_ x]\n  (if (number? x)\n    (double x)\n    x))\n\n(defn any->any [_ x] x)\n\n;;\n;; Maps\n;;\n\n(defn strip-extra-keys [{:keys [::parse/keys]} x]\n  (if (and keys (map? x))\n    (select-keys x keys)\n    x))\n\n;; TODO: remove this as it couples transformation & validation?\n(defn fail-on-extra-keys [{:keys [::parse/keys]} x]\n  (if (and (map? x) (not (set/subset? (-> x (clojure.core/keys) (set)) keys)))\n    ::s/invalid\n    x))\n\n;;\n;; Tuples\n;;\n\n(defn strip-extra-values [{:keys [::parse/items]} x]\n  (let [size (count items)]\n    (if (and (vector? x) (> (count x) size))\n      (subvec x 0 size)\n      x)))\n\n;;\n;; type decoders\n;;\n\n(def json-type-decoders\n  (merge\n    {:keyword string->keyword\n     :uuid (keyword-or-string-> string->uuid)\n     :date (keyword-or-string-> string->date)\n     :symbol (keyword-or-string-> string->symbol)\n     :long (keyword-> string->long)\n     :double (keyword-> string->double)\n     :boolean (keyword-> string->boolean)\n     :string keyword->string}\n    #?(:clj\n       {:uri nil\n        :bigdec nil\n        :ratio nil})))\n\n(def string-type-decoders\n  (merge\n    json-type-decoders\n    {:long (keyword-or-string-> string->long)\n     :double (keyword-or-string-> string->double)\n     :boolean (keyword-or-string-> string->boolean)}))\n\n(def strip-extra-keys-type-decoders\n  {:map strip-extra-keys})\n\n(def fail-on-extra-keys-type-decoders\n  {:map fail-on-extra-keys})\n\n(def strip-extra-values-type-decoders\n  {:tuple strip-extra-values})\n\n;;\n;; type encoders\n;;\n\n(def json-type-encoders\n  {:keyword keyword->string\n   :symbol any->string\n   :uuid any->string\n   :uri any->string\n   :bigdec any->string\n   :date date->string\n   :map any->any\n   :set any->any\n   :vector any->any\n   #?@(:clj [:ratio number->double])})\n\n(def string-type-encoders\n  (merge\n    json-type-encoders\n    {:long any->string\n     :double any->string}))\n"]}