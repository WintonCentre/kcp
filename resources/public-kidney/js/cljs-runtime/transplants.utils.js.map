{"version":3,"sources":["transplants/utils.cljs"],"mappings":";AAMA;;;0BAAA,AAAAA,YAAA,0BAAA,hEAAaC;AAEb;;;qCAAA,rCAAMC,kFAEHC;AAFH,AAGE,SAAK,GAAA,UAAA,TAAOA,sBAAO,GAAK,AAACC,4BAAcD;;AAEzC;;;oCAAA,pCAAME,gFAEHC,cAAcC,MAAMC;AAFvB,AAIE,OAACC,gBAAM,AAACC,4CAAI,AAACC,mBAAS,+DAAA,/DAACC,6CAAKC,uEAAc,CAACN,sCAAAA,qDAAAA,jBAAMD,iCAAAA,iBAAgBE;;AAEnE;;;0CAAA,1CAAMM,4FAEHR,cAAcC,MAAMC;AAFvB,AAGE,OAACC,gBAAM,AAACC,4CAAI,mBAAA,nBAACC,uEAAc,iBAAAI,eAAC,AAACC,gDAAQT;AAAV,AAAA,QAAAQ,6CAAAA,4DAAAA,jBAAiBT,wCAAAA;MAAgB,AAACW,eAAKT;;AAEpE;;;+BAAA,/BAAMU,sEAEHC;AAFH,AAGE,OAAC,oDAAA,sDAAA,yDAAA,wGAAA,3QAACC,oUAAgCD;;AAEpC;;;8BAAA,9BAAME,oEAEHF;AAFH,kGAGOA,7BACA,AAACD,rEACD,OAACI,4CAAIT;;AAEZ,AAKA;;;;8BAAA,9BAAMU,oEAGHC,MAAMjB;AAHT,AAIE,4DAAA,0IAAA,/LAACkB,+CAAOD,yFAAO,AAACR,gDAAQT;;AAE1B;;;kCAAA,lCAAMmB,4EAEHF,MAAMjB,MAAMoB;AAFf,AAGE,4DAAA,0IAAA,/LAACF,+CAAOD,yFAAO,AAACR,gDAAQT,+DAAcoB;;AAExC;;;;mCAAA,nCAAMC,8EAGHD,KAAKE;AAHR,AAIE,OAACb,gDAAQ,CAAK,AAACC,eAAKU,kDAAME;;AAE5B,yBAAA,zBAAKC;AACL,AAAKC,4BAAQ,0BAAA,zBAAGD;AAChB,AAAKE,0BAAM,0BAAA,zBAAGF;AACd,yBAAA,zBAAKG;AAEL,iCAAA,jCAAMC,0EACHC;AADH,AACM,OAACC,UAAa,CAAGD,IAAEF;;AACzB,kCAAA,lCAAMI,4EACHF;AADH,AACM,OAACC,UAAa,CAAGD,IAAEH;;AACzB,oCAAA,pCAAMM,gFACHH;AADH,AACM,OAACC,UAAa,CAAGD,IAAEJ;;AAGzB;;;kCAAA,lCAAMQ,4EAEHC,QAAQC;AAFX,AAGE,kBAAKC;AAAL,AAAQ,QAAI,CAACF,wCAAAA,2CAAAA,LAAQE,uBAAAA,OAAGD;;;AAE1B,AAsCA,iCAAA,jCAAME,0EACHC;AADH,AAEE,OAACC,WAAc,CAAGD,IAAEX;;AAEtB,oCAAA,pCAAMa,gFACHC;AADH,AAEE,OAACF,WAAc,CAAGE,IAAEhB;;AAEtB,AAKA;;;iCAAA,jCAAMiB,0EAEHb;AAFH,AAGE,OAACU,WAAc,KAAA,JAAGV;;AAEpB;;;iCAAA,jCAAMc,0EAEHC;AAFH,AAGE,OAACL,WAAc,KAAA,JAAGK;;AAEpB;;;AAAKC,8BAEH,AAACC,gDAAQC,gBAAMC,cAAIC;AAGrB;;;2CAAA,3CAAMC,8FAEHC;AAFH,AASO,mDAAA,WAAAG,vDAACtC;AAAD,AAAM,oDAAAsC,iBAAA,9DAACC;sQANPJ,hBACAhD,fACAiD,3DACA,2DAAA,eAAA,1EAACpC,4CAAIL,rNACL,+CAAA,iFAAA,cAAA,9IAAC0C;;AAMR;;;8CAAA,9CAAMG,oGAEHL;AAFH,AAKO,mDAAA,WAAAM,vDAACzC;AAAD,AAAM,OAACN,gDAAQ,CAAA,OAAY,eAAA+C,fAAC9C;4CAF5BwC,zCACA,AAACD","names":["js/goog.define","transplants.utils/ORGAN","transplants.utils/filled-in?","field","clojure.string/blank?","transplants.utils/get-centre-info","organ-centres","organ","centre","cljs.core/first","cljs.core.get","cljs.core/group-by","cljs.core.comp","cljs.core/keyword","transplants.utils/get-centre-info*","fexpr__67481","cljs.core.keyword","cljs.core/name","transplants.utils/path-names","path-params","cljs.core.juxt","transplants.utils/path-keys","cljs.core.map","transplants.utils/get-tools","mdata","cljs.core.get_in","transplants.utils/get-tool-meta","tool","transplants.utils/make-sheet-key","suffix","transplants.utils/year","transplants.utils/quarter","transplants.utils/month","transplants.utils/week","transplants.utils/day->week","d","js/Math.ceil","transplants.utils/day->month","transplants.utils/day->quarter","transplants.utils/day-in?","get-day","period","x","transplants.utils/week->day","w","js/Math.round","transplants.utils/quarter->day","q","transplants.utils/day->year","transplants.utils/year->day","y","transplants.utils/transpose","cljs.core.partial","cljs.core/apply","cljs.core/map","cljs.core/vector","transplants.utils/baseline-outcome-names","baseline-cifs","cljs.core/keys","cljs.core.remove","p1__67497#","cljs.core.subs","transplants.utils/baseline-cif-outcome-keys","p1__67499#"],"sourcesContent":["(ns transplants.utils\n  (:require [clojure.string :as string]\n            ;[shadow.debug :refer [?->]]\n            ))\n\n;; Define this in shadow build :closure-defines to select just one organ\n(goog-define ORGAN \"\")\n\n(defn filled-in?\n  \"Does a field contain something?\"\n  [field]\n  (and (some? field) (not (string/blank? field))))\n\n(defn get-centre-info\n  \"Locate the info for an organ & centre from organ-centres\"\n  [organ-centres organ centre]\n  ;(?-> centre ::centre)\n  (first (get (group-by (comp keyword :key) (organ organ-centres)) centre)))\n\n(defn get-centre-info*\n  \"Locate the info for an organ & centre from organ-centres\"\n  [organ-centres organ centre]\n  (first (get (group-by :key ((keyword organ) organ-centres)) (name centre))))\n\n(defn path-names\n  \"Given reitit path-params, return the organ/centre/tool path keys\"\n  [path-params]\n  ((juxt :organ :centre :tool :tab) path-params))\n\n(defn path-keys\n  \"Given reitit path-params, return the organ/centre/tool path keys\"\n  [path-params]\n  (->> path-params\n       (path-names)\n       (map keyword)))\n\n(comment\n  (path-keys {:organ \"k\" :centre \"c\" :tool \"t\"})\n  ;=> (:k :c :t)\n  )\n\n(defn get-tools\n  \"Returns a vector of tool keywords for an organ, read from mdata (data from /metadata.edn).\n  If mdata has not yet arrived, or organ is invalid, will return nil.\"\n  [mdata organ]\n  (get-in mdata [(keyword organ) :tool-order]))\n\n(defn get-tool-meta\n  \"returns tool metadata for an organ. Returns nil if called before mdata is available (i.e. if it's nil)\"\n  [mdata organ tool]\n  (get-in mdata [(keyword organ) :tools tool]))\n\n(defn make-sheet-key\n  \"Reconsruct a sheet key from a tool key and the sheet type suffix\n   e.g. :waiting '-inputs' -> :waiting-inputs\"\n  [tool suffix]\n  (keyword (str (name tool) suffix)))\n\n(def year 365.25)\n(def quarter (/ year 4))\n(def month (/ year 12))\n(def week 7)\n\n(defn day->week \n  [d] (js/Math.ceil (/ d week)))\n(defn day->month\n  [d] (js/Math.ceil (/ d month)))\n(defn day->quarter\n  [d] (js/Math.ceil (/ d quarter)))\n\n                  \n(defn day-in?\n  \"Given an x and an accessor function for day in x, discover whether the day is within given period of days\"\n  [get-day period]\n  (fn [x] (<= (get-day x) period)))\n\n(comment\n  (day->week 0)\n  ;; => 0\n  (day->week 1)\n  ;; => 1\n  (day->week 7)\n  ;; => 1\n  (day->week 8)\n  ;; => 2\n  (day->week 364)\n  ;; => 52\n  (day->week 365)\n  ;; => 53\n\n  (day->month 0)\n  ;; => 0\n  (day->month 30.4375)\n  ;; => 1\n  (day->month 30.4376)\n  ;; => 2\n  (day->month 365)\n  ;; => 12\n  (day->month 366)\n  ;; => 13\n\n  (day->quarter 1)\n  ;; => 1\n  (day->quarter 91)\n  ;; => 1\n  (day->quarter 92)\n  ;; => 2\n  (day->quarter 365)\n  ;; => 4\n  (day->quarter 366)\n  ;; => 5\n  )\n\n\n(defn week->day\n  [w]\n  (js/Math.round (* w week)))\n\n(defn quarter->day\n  [q]\n  (js/Math.round (* q quarter)))\n\n(comment\n  (quarter->day 1)\n  ;; => 91\n  )\n\n(defn day->year\n  \"Convert a day count to the nearest whole year\"\n  [d]\n  (js/Math.round (/ d 365.25)))\n\n(defn year->day\n  \"Convert a year count to the nearest whole day\"\n  [y]\n  (js/Math.round (* y 365.25)))\n\n(def transpose\n  \"transpose  matrix\"\n  (partial apply map vector))\n\n\n(defn baseline-outcome-names\n  \"extract the outcome-keys used in a raw baseline-cifs table, eliminating the cif- prefix\"\n  [baseline-cifs]\n  (->> baseline-cifs\n       first\n       keys\n       (map name)\n       (remove #{\"centre\" \"days\"})\n       ;(filter #(string/starts-with? % \"cif\"))\n       (map #(subs % 4))\n       ;(map keyword)\n       ))\n\n(defn baseline-cif-outcome-keys\n  \"extract the outcome-keys used in a raw baseline-cifs table, eliminating the cif- prefix\"\n  [baseline-cifs]\n  (->> baseline-cifs\n       (baseline-outcome-names)\n       (map #(keyword (str \"cif-\" (name %))))\n       ;(filter #(string/starts-with? % \"cif\"))\n       ;(map #(subs % 4))\n       ;(map keyword)\n       ))\n\n#_(defn baseline-cif-outcome-keys\n  \"extract the outcome-keys used in a raw baseline-cifs table, eliminating the cif- prefix\"\n  [baseline-cifs]\n  (->> baseline-cifs\n       first\n       keys\n       (map name)\n       (filter #(string/starts-with? % \"cif\"))\n       ;(map #(subs % 4))\n       (map keyword)))\n\n"]}