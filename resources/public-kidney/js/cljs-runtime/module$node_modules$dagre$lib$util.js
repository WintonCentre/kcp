shadow$provide.module$node_modules$dagre$lib$util=function(global,require,module,exports){function addDummyNode(g,type,attrs,name){do var v=_.uniqueId(name);while(g.hasNode(v));attrs.dummy=type;g.setNode(v,attrs);return v}function maxRank(g){return _.max(_.map(g.nodes(),function(v){v=g.node(v).rank;if(!_.isUndefined(v))return v}))}var _=require("module$node_modules$dagre$lib$lodash"),Graph=require("module$node_modules$dagre$lib$graphlib").Graph;module.exports={addDummyNode,simplify:function(g){var simplified=
(new Graph).setGraph(g.graph());_.forEach(g.nodes(),function(v){simplified.setNode(v,g.node(v))});_.forEach(g.edges(),function(e){var simpleLabel=simplified.edge(e.v,e.w)||{weight:0,minlen:1},label=g.edge(e);simplified.setEdge(e.v,e.w,{weight:simpleLabel.weight+label.weight,minlen:Math.max(simpleLabel.minlen,label.minlen)})});return simplified},asNonCompoundGraph:function(g){var simplified=(new Graph({multigraph:g.isMultigraph()})).setGraph(g.graph());_.forEach(g.nodes(),function(v){g.children(v).length||
simplified.setNode(v,g.node(v))});_.forEach(g.edges(),function(e){simplified.setEdge(e,g.edge(e))});return simplified},successorWeights:function(g){var weightMap=_.map(g.nodes(),function(v){var sucs={};_.forEach(g.outEdges(v),function(e){sucs[e.w]=(sucs[e.w]||0)+g.edge(e).weight});return sucs});return _.zipObject(g.nodes(),weightMap)},predecessorWeights:function(g){var weightMap=_.map(g.nodes(),function(v){var preds={};_.forEach(g.inEdges(v),function(e){preds[e.v]=(preds[e.v]||0)+g.edge(e).weight});
return preds});return _.zipObject(g.nodes(),weightMap)},intersectRect:function(rect,point){var x=rect.x,y=rect.y,dx=point.x-x;point=point.y-y;var w=rect.width/2,h=rect.height/2;if(!dx&&!point)throw Error("Not possible to find intersection inside of the rectangle");Math.abs(point)*w>Math.abs(dx)*h?(0>point&&(h=-h),rect=h*dx/point,dx=h):(0>dx&&(w=-w),rect=w,dx=w*point/dx);return{x:x+rect,y:y+dx}},buildLayerMatrix:function(g){var layering=_.map(_.range(maxRank(g)+1),function(){return[]});_.forEach(g.nodes(),
function(v){var node=g.node(v),rank=node.rank;_.isUndefined(rank)||(layering[rank][node.order]=v)});return layering},normalizeRanks:function(g){var min=_.min(_.map(g.nodes(),function(v){return g.node(v).rank}));_.forEach(g.nodes(),function(v){v=g.node(v);_.has(v,"rank")&&(v.rank-=min)})},removeEmptyRanks:function(g){var offset=_.min(_.map(g.nodes(),function(v){return g.node(v).rank})),layers=[];_.forEach(g.nodes(),function(v){var rank=g.node(v).rank-offset;layers[rank]||(layers[rank]=[]);layers[rank].push(v)});
var delta=0,nodeRankFactor=g.graph().nodeRankFactor;_.forEach(layers,function(vs,i){_.isUndefined(vs)&&0!==i%nodeRankFactor?--delta:delta&&_.forEach(vs,function(v){g.node(v).rank+=delta})})},addBorderNode:function(g,prefix,rank,order){var node={width:0,height:0};4<=arguments.length&&(node.rank=rank,node.order=order);return addDummyNode(g,"border",node,prefix)},maxRank,partition:function(collection,fn){var result={lhs:[],rhs:[]};_.forEach(collection,function(value){fn(value)?result.lhs.push(value):
result.rhs.push(value)});return result},time:function(name,fn){var start=_.now();try{return fn()}finally{console.log(name+" time: "+(_.now()-start)+"ms")}},notime:function(name,fn){return fn()}}}
//# sourceMappingURL=module$node_modules$dagre$lib$util.js.map
