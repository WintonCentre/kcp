{
"version":3,
"file":"module$node_modules$graphlib$lib$alg$dfs.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,wCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAgCrGC,QAASA,MAAK,CAACC,CAAD,CAAIC,CAAJ,CAAOC,SAAP,CAAkBC,OAAlB,CAA2BC,UAA3B,CAAuCC,GAAvC,CAA4C,CACnDC,CAAEC,CAAAA,GAAF,CAAMJ,OAAN,CAAeF,CAAf,CAAL,GACEE,OAAA,CAAQF,CAAR,CAMA,CANa,CAAA,CAMb,CAJKC,SAIL,EAJkBG,GAAIG,CAAAA,IAAJ,CAASP,CAAT,CAIlB,CAHAK,CAAEG,CAAAA,IAAF,CAAOL,UAAA,CAAWH,CAAX,CAAP,CAAsB,QAAQ,CAACS,CAAD,CAAI,CAChCX,KAAA,CAAMC,CAAN,CAASU,CAAT,CAAYR,SAAZ,CAAuBC,OAAvB,CAAgCC,UAAhC,CAA4CC,GAA5C,CADgC,CAAlC,CAGA,CAAIH,SAAJ,EAAiBG,GAAIG,CAAAA,IAAJ,CAASP,CAAT,CAPnB,CADwD,CA/B1D,IAAIK,EAAIV,OAAA,CAAQ,yCAAR,CAERC,OAAOC,CAAAA,OAAP,CAUAa,QAAY,CAACX,CAAD,CAAIY,EAAJ,CAAQC,KAAR,CAAe,CACpBP,CAAEQ,CAAAA,OAAF,CAAUF,EAAV,CAAL,GACEA,EADF,CACO,CAACA,EAAD,CADP,CAIA,KAAIR,WAA2DW,CAA7Cf,CAAEgB,CAAAA,UAAF,EAAA,CAAiBhB,CAAEiB,CAAAA,UAAnB,CAAgCjB,CAAEkB,CAAAA,SAAWH,EAAAA,IAA9C,CAAmDf,CAAnD,CAAjB,CAEIK,IAAM,EAFV,CAGIF;AAAU,EACdG,EAAEG,CAAAA,IAAF,CAAOG,EAAP,CAAW,QAAQ,CAACX,CAAD,CAAI,CACrB,GAAI,CAACD,CAAEmB,CAAAA,OAAF,CAAUlB,CAAV,CAAL,CACE,KAAUmB,MAAJ,CAAU,4BAAV,CAAyCnB,CAAzC,CAAN,CAGFF,KAAA,CAAMC,CAAN,CAASC,CAAT,CAAsB,MAAtB,GAAYY,KAAZ,CAA8BV,OAA9B,CAAuCC,UAAvC,CAAmDC,GAAnD,CALqB,CAAvB,CAOA,OAAOA,IAhBkB,CAb0E;",
"sources":["node_modules/graphlib/lib/alg/dfs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$graphlib$lib$alg$dfs\"] = function(global,require,module,exports) {\nvar _ = require(\"../lodash\");\n\nmodule.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nfunction dfs(g, vs, order) {\n  if (!_.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);\n\n  var acc = [];\n  var visited = {};\n  _.each(vs, function(v) {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n\n    doDfs(g, v, order === \"post\", visited, navigation, acc);\n  });\n  return acc;\n}\n\nfunction doDfs(g, v, postorder, visited, navigation, acc) {\n  if (!_.has(visited, v)) {\n    visited[v] = true;\n\n    if (!postorder) { acc.push(v); }\n    _.each(navigation(v), function(w) {\n      doDfs(g, w, postorder, visited, navigation, acc);\n    });\n    if (postorder) { acc.push(v); }\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","doDfs","g","v","postorder","visited","navigation","acc","_","has","push","each","w","dfs","vs","order","isArray","bind","isDirected","successors","neighbors","hasNode","Error"]
}
